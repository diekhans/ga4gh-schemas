@namespace("org.ga4gh.models")
/**
This protocol defines annotations on GA4GH genomic sequences It includes two
types of annotations: continuous and discrete hierarchical.

The discrete hierarchical annotations are  derived from the Sequence Ontology (SO) and GFF3 work
   http://www.sequenceontology.org/gff3.shtml

The goal is to be able to store annotations using the GFF3 and SO conceptual
model, although there is not necessarly a one-to-one mapping in Avro records
to GFF3 records.  One exception is that we don't include the alignment
attributes in the specification (Target and Gap), as we feel these are better
represented in a aligment-specific record and link to by the annotation.

The minimum requirement is to be able to accurately represent the current
state of the art annotation data and the full SO model.  SeqAnnRegion is the
core generic record which corresponds to the a GFF3 record.  These are
organized into a tree.  Special, not-tree cases are implemented by linking
objects via attributes and ids.  More specific record types (SeqAnnGene,
SeqAnnTranscript, etc) are provide to have a higher level representation for
the common case.  However, SeqAnnRegion objects can occur anywhere in the
tree. The lack of polymorphism support in Avro is compensated for by use of
unions.

FIXME: need much more documentation, describe differences and how tree here
still represents GFF3 DAG with attribute linking.

FIXME: should the discrete annotations be it's own protocol?
*/
protocol SequenceAnnotations {

import idl "common.avdl";

/**
Continuous numerical annotation along a region.
FIXME: more details and relate to UCSC browser tracks
*/
record Wiggle {
  /** 
  The region being described
  Note that we are fusing parts of BedGraph and Wig syntax.
  The region is being fully annotated, but can be divided into bins.
  If you have gaps, you need to define a sequence of such Wiggles. 
  */
  Region region;
 
  /**
  The values associated to this region.
  If this list contains _count_ elements, then the region is divided
  as cleanly as possible into _count_ bins of equal width. 
  We thus define a numerical function:

  value(position):
    if position < start or position >= start + length:
      return None
    else:
      return array[floor((position - start)*count/length)]
  */ 
  array<float> values = [];
}

/**
Data for annotated genome region.  
*/
record SeqAnnData {
  /**
  Genomic location.
  */
  Region region;

  /** Id of this annotation node. */
  union {null, string} id;

  /**
  Feature that is annotated by this region.  Normally, this will be a term in
  the Sequence Ontology.
  */
  OntologyTerm feature;
  
  /**
  Name/value attributes of annotation.
  */
  map<union {
    null,
    string,
    ExternalIdentifier,
    OntologyTerm
  }> attributes;
}
    
/**
Generic region hierarchical annotation node
*/
record SeqAnnRegion {
  /* Data for this region */
  SeqAnnData data;

  /**
  Component hierarchy of the annotation. 
  */
  array<SeqAnnRegion> components;
}
  
/**
CDS annotation 
*/
record SeqAnnCds {
  /* Data for this region */
  SeqAnnData data;

  /* coding phase */
  int phase;

  /**
  Component hierarchy of the annotation. 
  */
  array<SeqAnnRegion> components;
}

/**
5'UTR annotation 
*/
record SeqAnn5Utr {
  /* Data for this region */
  SeqAnnData data;

  /**
  Component hierarchy of the annotation. 
  */
  array<SeqAnnRegion> components;
}

/**
3'UTR annotation 
*/
record SeqAnn3Utr {
  /* Data for this region */
  SeqAnnData data;

  /**
  Component hierarchy of the annotation. 
  */
  array<SeqAnnRegion> components;
}

/**
Exon annotation 
*/
record SeqAnnExon {
  /* Data for this region */
  SeqAnnData data;

  /**
  Component hierarchy of the annotation. 
  */
  array<union {
    SeqAnnRegion,
    SeqAnnCds,
    SeqAnn5Utr,
    SeqAnn3Utr
  } > components;
}

/**
Intron annotation 
*/
record SeqAnnIntron {
  /* Data for this region */
  SeqAnnData data;

  string intronType; 

  /**
  Component hierarchy of the annotation. 
  */
  array<union {
    SeqAnnRegion
   }> components;
}

/**
Transcript hierarchical annotation 
*/
record SeqAnnTranscript {
  /* Data for this region */
  SeqAnnData data;

  /**
  Component hierarchy of the annotation. 
  */
  array<union {
    SeqAnnRegion,
    SeqAnnExon,
    SeqAnnIntron
   } > components;
}

/**
Gene hierarchical annotation 
*/
record SeqAnnGene {
  /* Data for this region */
  SeqAnnData data;

  /**
  Component hierarchy of the annotation. 
  */
  array<union {
    SeqAnnRegion,
    SeqAnnTranscript
   }> components;
}

/*
A set of annotations
*/
record SeqAnnSet {
  /** Id of this annotation node. */
  string id;

  /* FIXME: what else is needed  */
}  
}  
