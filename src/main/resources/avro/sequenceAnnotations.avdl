@namespace("org.ga4gh.models")
/**
This protocol defines annotations on GA4GH genomic sequences It includes two
types of annotations: continuous and discrete hierarchical.

The discrete hierarchical annotations are  derived from the Sequence Ontology (SO) and GFF3 work
   http://www.sequenceontology.org/gff3.shtml

The goal is to be able to store annotations using the GFF3 and SO conceptual
model, although there is not necessarly a one-to-one mapping in Avro records
to GFF3 records.  One exception is that we don't include the alignment
attributes in the specification (Target and Gap), as we feel these are better
represented in a aligment-specific record and link to by the annotation.

The minimum requirement is to be able to accurately represent the current
state of the art annotation data and the full SO model.  SeqAnnRegion is the
core generic record which corresponds to the a GFF3 record.  These are
organized into a tree.  Special, not-tree cases are implemented by linking
objects via attributes and ids.  More specific record types (SeqAnnGene,
SeqAnnTranscript, etc) are provide to have a higher level representation for
the common case.  However, SeqAnnRegion objects can occur anywhere in the
tree. The lack of polymorphism support in Avro is compensated for by use of
unions.

FIXME: need much more documentation, describe differences and how tree here
still represents GFF3 DAG with attribute linking.

FIXME: should the discrete annotations be it's own protocol?
*/
protocol SequenceAnnotations {

import idl "common.avdl";

/**
Continuous numerical annotation along a region.
FIXME: more details and relate to UCSC browser tracks
*/
record Wiggle {
  /** 
  The region being described
  Note that we are fusing parts of BedGraph and Wig syntax.
  The region is being fully annotated, but can be divided into bins.
  If you have gaps, you need to define a sequence of such Wiggles. 
  */
  Region region;
 
  /**
  The values associated to this region.
  If this list contains _count_ elements, then the region is divided
  as cleanly as possible into _count_ bins of equal width. 
  We thus define a numerical function:

  value(position):
    if position < start or position >= start + length:
      return None
    else:
      return array[floor((position - start)*count/length)]
  */ 
  array<float> values = [];
}

/**
Feature category.  This is an categorization of the feature ontology terms
for common terms intended to make programming easier.
*/
enum SeqAnnFeatureCategory {
  FEATURE_OTHER,
  FEATURE_GENE,
  FEATURE_TRANSCRIPT,
  FEATURE_EXON,
  FEATURE_INTRON,
  FEATURE_5UTR,
  FEATURE_CDS,
  FEATURE_3UTR
}
  
/**
Hierarchical region annotation node.
*/
record SeqAnnRegion {
  /**
  Genomic location.
  */
  Region region;

  /** Id of this annotation node. */
  union {null, string} id;

  /**
  Feature that is annotated by this region.  Normally, this will be a term in
  the Sequence Ontology.
  */
  OntologyTerm feature;

  /**
   Feature category.  This is an categorization of the feature ontology term
   for common terms intended to make programming easier.
  */
  SeqAnnFeatureCategory featureCategory;

  /**
     phase for CDS, or -1 if not CDS
   */
  int phase;
  
  /**
  Name/value attributes of annotation.
  */
  map<union {
    null,
    string,
    ExternalIdentifier,
    OntologyTerm
  }> attributes;

  /**
  Component hierarchy of the annotation. 
  */
  array<SeqAnnRegion> components;
}
    
}  
