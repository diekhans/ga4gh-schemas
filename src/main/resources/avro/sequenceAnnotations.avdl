@namespace("org.ga4gh.models")
/**
This protocol defines annotations on GA4GH genomic sequences It includes two
types of annotations: continuous and discrete hierarchical.

The discrete hierarchical annotations are  derived from the Sequence Ontology (SO) and GFF3 work
   http://www.sequenceontology.org/gff3.shtml

The goal is to be able to store annotations using the GFF3 and SO conceptual
model, although there is not necessarly a one-to-one mapping in Avro records
to GFF3 records.  One exception is that we don't include the alignment
attributes in the specification (Target and Gap), as we feel these are better
represented in a aligment-specific record and link to by the annotation.

The minimum requirement is to be able to accurately represent the current
state of the art annotation data and the full SO model.  SeqAnnRegion is the
core generic record which corresponds to the a GFF3 record.  These are
organized into a tree.  Special, not-tree cases are implemented by linking
objects via attributes and ids.  More specific record types (SeqAnnGene,
SeqAnnTranscript, etc) are provide to have a higher level representation for
the common case.  However, SeqAnnRegion objects can occur anywhere in the
tree. The lack of polymorphism support in Avro is compensated for by use of
unions.

FIXME: need much more documentation, describe differences and how tree here
still represents GFF3 DAG with attribute linking.

FIXME: should the discrete annotations be it's own protocol?
*/
protocol SequenceAnnotations {

  import idl "common.avdl";

  /**
  Continuous numerical annotation along a region.
  */
  record SeqAnnWiggle {
    /**
    The region being described
    Note that we are fusing parts of UCSC BedGraph and Wiggle syntax.
    The region is being fully annotated, but can be divided into bins.
    If you have gaps, you need to define a sequence of such Wiggles.
    */
    Region region;

    /**
    The values associated to this region.
    If this list contains _count_ elements, then the region is divided
    as cleanly as possible into _count_ bins of equal width.
    We thus define a numerical function:

    value(position):
      if position < start or position >= start + length:
        return None
      else:
        return array[floor((position - start)*count/length)]
    */
    array<float> values = [];
  }

  /*
  A set of wiggle annotations
  */
  record SeqAnnWiggleSet {
    /** Id of this annotation node. */
    string id;

    /* FIXME: what else is needed.   */
  }
  /**
  Hierarchical region annotation node.
  */
  record SeqAnnRegion {
    /**
    Id of this annotation node.  Only require for nodes that need to be linked
    outside of the tree or non-tree linking of nodes within the tree (e.g. Derived_from)
    */
    union {null, string} id;

    /**
    Identifier for the containing annotation set.
    */
    string annotationSetId;

    /**
    Genomic location.
    */
    Region region;

    /**
    Feature that is annotated by this region.  Normally, this will be a term in
    the Sequence Ontology.
    */
    OntologyTerm feature; // TODO(calbach): Would prefer <something>Type.

    /**
    Name/value attributes of annotation.
    */
    map<union {
      string,
      ExternalIdentifier,
      OntologyTerm
    }> attributes;

    /**
    Identifier for the parent annotation, if any.
    */
    string parentId;
  }

  /*
  A set of region annotations
  */
  record SeqAnnRegionSet {
    /** Id of this annotation node. */
    string id;

    /* FIXME: what else is needed.   */
  }
}
